module.exports = (function() {
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */

  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
    return '"' + s
            .replace(/\\/g, '\\\\') // backslash
            .replace(/"/g, '\\"') // closing quote character
            .replace(/\x08/g, '\\b') // backspace
            .replace(/\t/g, '\\t') // horizontal tab
            .replace(/\n/g, '\\n') // line feed
            .replace(/\f/g, '\\f') // form feed
            .replace(/\r/g, '\\r') // carriage return
            .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
  }

  var result = {
    /*
     * Compiles the AST to javascript code for a function
     */
    compile: function(AST) {
      var code = null;

      /* 2 Ways to Create Functions:
       * 1. using eval
       *    eval("var func = function(arg1) { return arg1; }")
       *    Notice that we both created the function and assigned it to a variable
       *    in the eval (this is required, because function definition is like
       *    function func_name(arg1) { ... body ... }
       *    What we are creating is an anoymous function, and that can only
       *    be used either by
       *    i) assigning the anonymous function to a variable (like above)
       *    ii) creating the function and immediately calling it (something like
       *    (function(arg1) { return arg1; })(1);
       *  2. Through the function object (i.e. without eval)
       *    var f = new Function('arg1','return arg1;')
       */

      if (isAST(AST)) { // If Single Line, convert to multiline aray
        AST = [AST];
      } else if (!isArray(AST)) {
        AST = null;
      }

      if ((AST !== null) && isArray(AST) && AST.length > 0) {
        /* function prototype would be something like:
         * function (value) {
         *   ....
         *   return result;
         * }
         * 
         * Where:
         * 1 "value" is the value to be tested against the conditions.
         * 2. "result" is a boolean return, such that "TRUE" means passes, "FALSE" otherwise
         */
        var expression = null;
        var compiled = null;
        for (var i = 0; i < AST.length; ++i) {
          expression = AST[i];
          if (!isAST(expression)) {
            // Invalid Value in AST, skip
            continue;
          }

          // Compile the expression
          compiled = compile_expression(expression, code !== null);
          if (compiled === null) {
            // Failed to compile the expression
            continue;
          }

          code = code === null ? compiled : code + '\n' + compiled;
        }
      }

      if (code !== null) {
        code = new Function("value", code + "\n  return result;");
      }

      function isObject(a) {
        return a != null ? typeof a === 'object' : false;
      }
      function isArray(a) {
        return isObject(a) ? Object.prototype.toString.call(a) === '[object Array]' : false;
      }
      function isAST(a) {
        return isObject(a) ? a.hasOwnProperty('type') && a.hasOwnProperty('children') : false;
      }
      function isAST_of_Type(a, type) {
        return isAST(a) ? a['type'] === type : false;
      }

      /*
       * Compiles an 'expression' AST
       */
      function compile_expression(expression, multiline) {
        var code = null;

        var child = expression.hasOwnProperty('children') ? expression['children'] : null;
        if (isAST(child)) {
          switch (child.type) {
            case 'comparison':
              code = compile_comparison(child);
              break;
            case 'list':
              code = compile_list(child);
              break;
            case 'range':
              code = compile_range(child);
              break;
          }
        }

        return code;
      }
      /*
       * Compiles a 'comparison' AST
       */
      function compile_comparison(comparison) {
        /* for a comparison we expect
         * a) 2 children AST Objects
         * b) 1st Child Operator
         * c) 2nd Child Value
         */
        var code = null;

        if (isArray(comparison['children']) &&
                (comparison['children'].length == 2)) {
          var operator = operator_to_JS(comparison['children'][0]);
          var value = value_to_JS(comparison['children'][1]);

          if ((operator !== null) && (value !== null)) {
            return '  var result = value' + operator + " " + value + ";\n";
          }
        }
        return code;
      }
      /*
       * Compiles a 'list' AST
       */
      function compile_list(list) {
        var code = null;
        var children = list['children'];
        if (isArray(children)) {
          // build array
          var array = '  var __array=['
          var value = null;
          var count = 0;
          for (var i = 0; i < children.length; ++i) {
            value = value_to_JS(children[i]);
            if (value !== null) {
              array += count++ == 0 ? value : ', ' + value;
            }
          }
          array += '];\n';

          if (count) {
            code = array + '\n' +
                    '  result=true;\n' +
                    '  for(var __i=0; _i < __array.length; ++__i) {\n' +
                    '    if(value != __array[__i]) {\n' +
                    '      result = false;\n' +
                    '      break;\n' +
                    '    }\n' +
                    '  }';
          }
        }

        return code;
      }
      /*
       * Compiles a 'range' AST
       */
      function compile_range(range) {
        var children = range['children'];
        if (isArray(children) && (children.length == 2)) {
          var lower_limit = isAST_of_Type(children[0], 'value') ? value_to_JS(children[0]) : null;
          var upper_limit = isAST_of_Type(children[1], 'value') ? value_to_JS(children[1]) : null;

          if ((lower_limit !== null) && (upper_limit !== null)) {
            var lower_exclude = range.start === ']' ? '>' : '>=';
            var upper_exclude = range.end === '[' ? '<' : '<=';

            return '  var result = (value' + lower_exclude + ' ' + lower_limit + ') &&\n' +
                    '               (value' + upper_exclude + ' ' + upper_limit + ');\n';
          }
        }
        return null;
      }
      function operator_to_JS(operator) {
        if (isAST(operator) && (operator['type'] === 'OPERATOR')) {
          return operator['children'];
        }

        return null;
      }
      function value_to_JS(value) {
        if (isAST(value) && (value['type'] === 'value')) {
          var real_value = value['children'];
          if (isAST(real_value)) {
            return real_value['children'];
          }
        }

        return null;
      }

      return code;
    },
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "expression": parse_expression,
        "list": parse_list,
        "range": parse_range,
        "value": parse_value,
        "OPERATOR": parse_OPERATOR,
        "STRING": parse_STRING,
        "TIME": parse_TIME,
        "NUMBER": parse_NUMBER,
        "WS": parse_WS
      };

      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "expression";
      }

      var pos = {
        offset: 0,
        line: 1,
        column: 1,
        seenCR: false
      };
      var reportFailures = 0;
      var rightmostFailuresPos = {
        offset: 0,
        line: 1,
        column: 1,
        seenCR: false
      };
      var rightmostFailuresExpected = [];

      function padLeft(input, padding, length) {
        var result = input;

        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }

        return result;
      }

      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;

        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }

        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }

      function clone(object) {
        var result = {};
        for (var key in object) {
          result[key] = object[key];
        }
        return result;
      }

      function advance(pos, n) {
        var endOffset = pos.offset + n;

        for (var offset = pos.offset; offset < endOffset; offset++) {
          var ch = input.charAt(offset);
          if (ch === "\n") {
            if (!pos.seenCR) {
              pos.line++;
            }
            pos.column = 1;
            pos.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            pos.line++;
            pos.column = 1;
            pos.seenCR = true;
          } else {
            pos.column++;
            pos.seenCR = false;
          }
        }

        pos.offset += n;
      }

      function matchFailed(failure) {
        if (pos.offset < rightmostFailuresPos.offset) {
          return;
        }

        if (pos.offset > rightmostFailuresPos.offset) {
          rightmostFailuresPos = clone(pos);
          rightmostFailuresExpected = [];
        }

        rightmostFailuresExpected.push(failure);
      }

      /* expression
       *   = o:OPERATOR WS v:value  { return '** ' + o + ' ' + v + ' **'; }
       *   / ']' WS range WS ']'
       *   / '['  WS (( list WS ']' ) / ( range WS ('[' / ']')))
       */

      function parse_expression() {
        var result0 = null, result1;
        var pos0;

        if (input != null) {
          // Create a Marker (START)
          pos0 = clone(pos);

          // PATH 1 : = o:OPERATOR WS v:value  { return '** ' + o + ' ' + v + ' **'; }
          result0 = parse_OPERATOR();
          if (result0 !== null) {
            // Skip Whitespaces
            parse_WS();

            result1 = parse_value();
            if (result1 !== null) {
              /* Adding this fake 'comparison' AST, makes the expression object "flat"
               * i.e. the children is never an array, but a direct reference
               */
              return {type: 'expression', children: {
                  type: 'comparison', children: [result0, result1]
                }
              };
            }
          }

          // BACK TRACK to (START)
          pos = pos0;
          if (input.charCodeAt(pos.offset) === 93) {
            // PATH 2 : / ']' range (']' | '[')
            advance(pos, 1);

            // Skip Whitespaces
            parse_WS();

            result0 = parse_range();

            if (result0 !== null) { // Match Range Close
              // Skip Whitespaces
              parse_WS();

              // Match Range Close
              if ((input.charCodeAt(pos.offset) === 91) || // [
                      (input.charCodeAt(pos.offset) === 93)) { // ]
                result0.start = ']';
                result0.end = input[pos.offset];
                advance(pos, 1); // NOT REALLY REQUIRED as 'expression' is the top level clause and we are exiting
                return {type: 'expression', children: result0};
              }
            }
          } else if (input.charCodeAt(pos.offset) === 91) {
            // PATH 3 : / '['  WS (( list WS ']' ) / ( range WS ('[' / ']')))
            advance(pos, 1);

            // Skip Whitespaces
            parse_WS();

            // Need a Second Marker to Back Track (Trying both List and Range)
            pos0 = clone(pos);

            result0 = parse_list();
            if (result0 !== null) {
              // Skip Whitespaces
              parse_WS();

              if (input.charCodeAt(pos.offset) === 93) {
                advance(pos, 1); // NOT REALLY REQUIRED as 'expression' is the top level clause and we are exiting
                return {type: 'expression', children: result0};
              }
            }

            // BACK TRACK
            pos = pos0;

            result0 = parse_range();
            if (result0 !== null) { // Match Range Close
              // Skip Whitespaces
              parse_WS();

              if ((input.charCodeAt(pos.offset) === 91) || // [
                      (input.charCodeAt(pos.offset) === 93)) { // ]
                result0.start = '[';
                result0.end = input[pos.offset];
                advance(pos, 1); // NOT REALLY REQUIRED as 'expression' is the top level clause and we are exiting
                return {type: 'expression', children: result0};
              }
            }
          }
        }


        if (reportFailures === 0) {
          matchFailed("EXPRESSION:");
        }
        return null;
      }

      /* list
       *   = a:value b:( WS ',' WS value)* { return b != null ? a+b.join(""): a}
       */

      function parse_list() {
        var result0, result1;

        result0 = [];
        result1 = parse_value();
        while (result1 !== null) {
          result0.push(result1);

          // Skip Whitespaces
          parse_WS();

          // Look for Next Comma
          if (input.charCodeAt(pos.offset) === 44) {
            advance(pos, 1);

            // Skip Whitespaces
            parse_WS();

            // Get Next Value
            result1 = parse_value();
            if (result1 == null) { // Failed to Parse Value
              result0 = null;
              break;
            }
          } else {
            break;
          }
        }

        if ((reportFailures === 0) && (result0 === null)) {
          matchFailed("LIST: value [, value]*");
          return null;
        }

        return {type: 'list', children: result0};
      }

      /* range
       *   = a:value WS .. WS b:value { return a + ' .. ' + b}
       */

      function parse_range() {
        var result1, result2;

        // 1st Value
        result1 = parse_value();

        if (result1 !== null) {
          // Skip Whitespaces
          parse_WS();

          if ((input.charCodeAt(pos.offset) === 46) &&
                  (input.charCodeAt(pos.offset + 1) === 46)) {
            advance(pos, 2);

            // Skip Whitespaces
            parse_WS();

            // 2nd Value
            result2 = parse_value();
            if (result2 !== null) { // Failed to Parse Value
              return {type: 'range', children: [result1, result2]};
            }
          }
        }

        if (reportFailures === 0) {
          matchFailed("RANGE: value .. value");
        }

        return null;
      }

      /* value 
       *   = a:SIGN? b:NUMBER { return a != null ? a+b.join("") : a }
       *   / TIME
       *   / STRING
       */

      function parse_value() {
        var result0 = null;

        // MARKER : Starting Point for Match 
        pos0 = clone(pos);

        // PATH 1 : = a:SIGN? b:NUMBER { return a != null ? a+b.join("") : a }
        result0 = parse_NUMBER();
        if (result0 === null) {
          // BACK TRACK
          pos = clone(pos0);

          // PATH 2 : / TIME
          result0 = parse_TIME();
          if (result0 === null) {
            // BACK TRACK
            pos = pos0; // OPTIMIZATION : No Need to Clone as the Marker will not be Re-Used

            // PATH 3 : / STRING
            result0 = parse_STRING();
          }
        }

        return result0 !== null ? {type: 'value', children: result0} : null;
      }

      /* OPERATOR
       *   = a:'<' b:'='? { return b != null ? a+b : a }
       *   / a:'>' b:'='? { return b != null ? a+b : a }
       *   / '=' { return '==' }
       *   / '!' { return '!=' }
       */

      function parse_OPERATOR() {
        var result0 = null;

        switch (input.charCodeAt(pos.offset)) {
          case 60: // PATH 1 : = a:'<' b:'='? { return b != null ? a+b : a }
            result0 = "<";
            advance(pos, 1);
            if (input.charCodeAt(pos.offset) === 61) {
              result0 = "<=";
              advance(pos, 1);
            }
            break;
          case 62: // PATH 2 : / a:'>' b:'='? { return b != null ? a+b : a }
            result0 = ">";
            advance(pos, 1);
            if (input.charCodeAt(pos.offset) === 61) {
              result0 = ">=";
              advance(pos, 1);
            }
            break;
          case 61: // PATH 3 : / '='
            result0 = "=";
            advance(pos, 1);
            break;
          case 33:         // PATH 4 : / '!'
            result0 = "!";
            advance(pos, 1);
        }

        if ((reportFailures === 0) && (result0 === null)) {
          matchFailed("OPERATOR: <, <=, >, >=, =, !");
          return null;
        }

        return {type: 'OPERATOR', children: result0};
      }

      function parse_STRING() {
        var result0 = null;
        var start_quote = null;
        var escape_active = false;

        // Start of String Marker
        var start = clone(pos);

        // Match Starting Quote Character
        if ((input.charCodeAt(pos.offset) === 34) ||
                (input.charCodeAt(pos.offset) === 39)) {
          start_quote = input.charCodeAt(pos.offset);
          advance(pos, 1);
        } else {
          if (reportFailures === 0) {
            matchFailed("STRING: Missing Start Quote. Expecting \" or \'");
          }
          return null;
        }

        var next_char = input.charCodeAt(pos.offset);
        while (next_char) {
          if (next_char == 92) { // Escape Character '\'
            // Toggle Escape Character
            escape_active ^= true;
            advance(pos, 1);
          } else if (next_char != start_quote) { // Next Character
            escape_active = false;
            advance(pos, 1);
          } else if (escape_active) {
            advance(pos, 1);
          } else { // Found End Quote
            break;
          }

          // Get the Next Character
          next_char = input.charCodeAt(pos.offset);
        }

        if (input.charCodeAt(pos.offset) === start_quote) {
          // Found Ending Quote
          advance(pos, 1);
          result0 = input.substring(start.offset, pos.offset);
          return {type: 'STRING', children: result0};
        }

        if (reportFailures === 0) {
          matchFailed("STRING: Missing End Quote.");
        }

        return null;
      }

      /* TIME "time"
       *   = '%' [0-9] [0-9]? ':' [0-9] [0-9] (':' [0-9] [0-9])? '%'
       */

      function parse_TIME() {
        var result0 = /^\%((2[0-3]|([0-1][0-9]))(\:[0-5][0-9]){1,2})\%/.exec(input.substring(pos.offset));

        if (result0 !== null) {
          advance(pos, result0[0].length); // Move Forward to End of Time String
          result0 = result0[1]; // Extract 1st RexExp Group which is just the Time without the '%'
          return {type: 'TIME', children: result0};
        }

        if (reportFailures === 0) {
          matchFailed("TIME : %HH:MM[:SS]%");
        }

        return null;
      }

      /* NUMBER "numeric"
       *   = '.' INTEGER EXPONENT?
       *   / INTEGER ('.' INTEGER?)? EXPONENT?
       */

      function parse_NUMBER() {
        var result0 = /^[+-]?((\.\d([eE][+-]?\d+)?)|(\d\.?\d?([eE][+-]?\d+)?))/.exec(input.substring(pos.offset));

        if (result0 !== null) {
          result0 = result0[0];
          advance(pos, result0.length);
          return {type: 'NUMBER', children: result0};
        }

        if (reportFailures === 0) {
          matchFailed("NUMBER: .INTEGER[EXPONENT] or INTEGER[.[INTEGER][EXPONENT]]");
        }

        return null;
      }

      /* WS "white spaces"
       *   = ' '* { return '' }
       */

      function parse_WS() {
        var result0;

        // Start of String Marker
        var start = clone(pos);

        while (input.charCodeAt(pos.offset) === 32) {
          advance(pos, 1);
        }

        // Extract Whitespaces Skipped (if any)
        result0 = start.offset < pos.offset ? input.substring(start.offset, pos.offset) : null;

        if ((reportFailures === 0) && (result0 === null)) {
          matchFailed("WHITE SPACES: \b*");
          return null;
        }

        return {type: 'WS', children: result0};
      }

      function cleanupExpected(expected) {
        expected.sort();

        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }

      var result = parseFunctions[startRule]();

      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos.offset === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos.offset < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos.offset === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos.offset !== input.length) {
        var offset = Math.max(pos.offset, rightmostFailuresPos.offset);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = pos.offset > rightmostFailuresPos.offset ? pos : rightmostFailuresPos;

        throw new this.SyntaxError(
                cleanupExpected(rightmostFailuresExpected),
                found,
                offset,
                errorPosition.line,
                errorPosition.column
                );
      }

      return result;
    },
    /* Returns the parser source code. */
    toSource: function() {
      return this._source;
    }
  };

  /* Thrown when a parser encounters a syntax error. */

  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;

      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ") + " or " + expected[expected.length - 1];
      }

      foundHumanized = found ? quote(found) : "end of input";

      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }

    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };

  result.SyntaxError.prototype = Error.prototype;

  return result;
})();

/*
 process.argv.forEach(function (val, index, array) {
 console.log(index + ': ' + val);
 });
 */

var results = module.exports.parse(process.argv[2]);

if (results !== null) {
  console.log(JSON.stringify(results, null, 4));
  console.log(module.exports.compile(results));
} else {
  console.log("ERROR: **Parser Failed");
}
